package com.adesim.objects;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Polygon;
import java.awt.geom.Point2D;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.UUID;

import utilities.ColorConverter;
import utilities.xml.Xml;

import ade.gui.Util;

import com.adesim.datastructures.ObjectsHolder;
import com.adesim.datastructures.SimShape;
import com.adesim.gui.PopupObjectAction;
import com.adesim.objects.model.ObjectMover;
import com.adesim.objects.model.SimModel;
import com.adesim.util.SimUtil;

/**Identifies an object as a sim-entity (Wall, Landmark, Block, etc)*/
public abstract class SimEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	private UUID guid = SimUtil.generateGUID();
	private UUID containingObjectID = null;


	private SimShape shape;
	private String type;
	private String name; // or null
	private Long time = null;
        private static Long visionTokenIdCount = -2L;
	private boolean laserable;
	private Color colorAssigned; // null if not assigned
	private Color colorDefault; // the default color for the visualization (if assigned = null)

	private boolean autoGeneratedName = false; // indicates whether the name was auto-generated.

	private ArrayList<String> cachedDescriptions = null; // list of descriptions that is cached for efficiency,
	//   once the list is compiled by the getDescriptions call, but is also invalidated (and hence requires
	//   re-generation) if the name of the object changes.

	public SimEntity(SimShape shape, String name, String type, boolean laserable,
					 Color colorAssigned, Color colorDefault) {
		this.shape = shape;

		// always want to have a name, just to avoid null-pointer-exceptions with
		//      ADEPercepts, etc.  If none specified, use the GUID
		if (name == null) {
			autoGeneratedName = true;
			name = guid.toString();
		}
		this.name = name;
                visionTokenIdCount += 2;
		this.time = visionTokenIdCount;

		this.type = type;
		this.laserable = laserable;
		this.colorAssigned = colorAssigned;
		this.colorDefault = colorDefault;

		if (shape != null) {
			shape.assignDefaultZLengthIfNonePresent(defaultZLength());
		}
	}

	/** every object should have a default z-length ("height") in case none was assigned */
	public abstract double defaultZLength();

	/** for very minimalist "ticking" of objects.*/
	public abstract void tick(SimModel model);

	/** generateXML to be able to save current config */
	public abstract Xml generateXML();



	/******* GUI-RELATED ABSTRACT METHODS ********/

	/** for GUI:*/
	public abstract String getToolTipIfAny();

	public abstract void performAnyPostPainting(Polygon shapeOnScreen, Graphics g);

	/** for GUI:  identifies GUI-accessible actions associated with the object.
	 * The options can be seen in a context menu when the object is right-clicked*/
	public abstract ArrayList<PopupObjectAction> getPopupObjectActions();




	/******* COMMON IMPLEMENTED-BY-THIS-BASE-CLASS METHODS ********/


	/** makes true deep clone of the object (via serializing and de-serializing itself).  the ONLY
	 * difference is that the guid is generated anew (otherwise would hardly be unique!), and
	 * containingObjectID is set, by default, to NULL (since if something contained it,
	 * would need to be notified separately; you can't just go up to someone saying "hey, I'm your child").
	 */
	public SimEntity clone() {
		// create deep clone by serializing the object and de-serializing
		try {
			ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
			ObjectOutputStream objectOut = new ObjectOutputStream(byteOut);
			objectOut.writeObject(this);
			byte[] bytes = byteOut.toByteArray();
			ByteArrayInputStream byteIn = new ByteArrayInputStream(bytes);
			ObjectInputStream objectIn = new ObjectInputStream(byteIn);

			SimEntity clonedResult = (SimEntity) objectIn.readObject();

			clonedResult.guid = SimUtil.generateGUID();
			if (clonedResult.autoGeneratedName) {
				clonedResult.name = clonedResult.guid.toString();
			}
			clonedResult.containingObjectID = null; // object is FREE from any parents --
			//     until it gets moved over them.

			updateObjectsHolderAndCloneContainedObjectsIfAny(clonedResult);

			return clonedResult;

		} catch (Exception e) {
			// this is really only to appease Java.  The class it's trying to clone is THIS
			//     class, of course this should work.
			System.err.println("Could not clone object!");
			e.printStackTrace();
			return null;
		}
	}



	private void updateObjectsHolderAndCloneContainedObjectsIfAny(SimEntity newSimEntity) {
		if (newSimEntity instanceof SimContainerEntity) {
			ObjectsHolder newHolder = new ObjectsHolder(newSimEntity.getGUID());
			// iterate over existing objects, make clones of them (that way will also recursively
			//     copy containers inside containers, btw), and add then to a new object holder.
			for (SimEntity containedObject : ((SimContainerEntity) newSimEntity).getObjectsHolder().getObjects()) {
				SimEntity clonedContainedObject = containedObject.clone();
				// link to its parent, the newly created object
				clonedContainedObject.containingObjectID = newSimEntity.getGUID();
				newHolder.add(clonedContainedObject);
			}
			((SimContainerEntity) newSimEntity).setObjectsHolder(newHolder);
		}
	}


	/** returns a list of descriptions that can be used to query for the object.  if list has
	 * been invalidated recently, will regenerate it and cache it for future use.  */
	public final Iterable<String> getDescriptions() {
		if (this.cachedDescriptions == null) {
			cachedDescriptions = new ArrayList<String>();
			cachedDescriptions.add(type);
			if (name != null) {
				cachedDescriptions.add(name);
			}
		}
		return cachedDescriptions;
	}

	/** Unique ID for the object */
	public final UUID getGUID() {
		return guid;
	}

	/** gets the object that contains this object, or NULL if it's an object rooted in the environment */
	public final UUID getContainingObjectID() {
		return containingObjectID;
	}

	public final void setContainingObjectID(UUID containingObjectID) {
		this.containingObjectID = containingObjectID;
	}


	public final SimShape getShape() {
		return shape;
	}

	/** sets shape to a new shape -- can be used both externally (environment receives command that
	 * the simEntity's shape has changed to X), or by subclasses.
	 * @param newShape
	 */
	public void setShape(SimShape newShape) {
		this.shape = newShape;
	}


	public final boolean isLaserVisible() {
		return laserable;
	}

	public final String getName() {
		return name;
	}

	public final long getTime() {
		return time;
	}

	public final void setName(String newName) {
		this.name = newName;
		// if went through the trouble of a setName call, must not be an auto-generated name (anymore, anyway)
		this.autoGeneratedName = false;
		// also invalidate description name, so now can include new name:
		this.cachedDescriptions = null;
	}


	public final String getType() {
		return type;
	}

	/** for GUI and precepts:*/
	public final Color getColorAssigned() {
		return colorAssigned;
	}

	/** for GUI:*/
	public final Color getColorDefault() {
		return colorDefault;
	}

	public Color getColorAssignedOrDefault() {
		if (colorAssigned == null) {
			return colorDefault;
		} else {
			return colorAssigned;
		}
	}

	/** criteria must be all lower case!  for matching anything, include
	 * the wildcard character, "*", as one of the strings in the criteria.
	 */
	public boolean matchesDescription(HashSet<String> criteria) {
		// if matches wildcard, return true immediately
		if (criteria.contains("*")) {
			return true;
		}

		for (String eachDescription : this.getDescriptions()) {
			if (criteria.contains(eachDescription.toLowerCase())) {
				return true;
			}
		}

		// if haven't quit yet:
		return false;
	}


	/******* Useful helpers *******/
	public final String getNameOrType(boolean quoteName) {
		String nameIfNotAutoGenerated = getNameIfNotAutoGenerated(quoteName);
		if (nameIfNotAutoGenerated == null) { // WAS auto-generated
			return type;
		} else {
			return nameIfNotAutoGenerated;
		}
	}

	protected final String getNameIfNotAutoGenerated(boolean quoteName) {
		if (!autoGeneratedName) {
			if (quoteName) {
				return Util.quotational(name);
			} else {
				return name;
			}
		}
		// otherwise return null;
		return null;
	}

	protected void addNameAttributeIfItExists(Xml xml) {
		if (!autoGeneratedName) {
			xml.addAttribute("name", this.name);
		}
	}

	protected void addColorChildIfItExists(Xml xml) {
		if (colorAssigned != null) {
			Xml colorXml = xml.addChild(new Xml("color"));

			String exactMatchColor = ColorConverter.getExactMatchColorNameIfAny(this.colorAssigned);
			if (exactMatchColor == null) {
				colorXml.addAttribute("red", Integer.toString(colorAssigned.getRed()));
				colorXml.addAttribute("green", Integer.toString(colorAssigned.getGreen()));
				colorXml.addAttribute("blue", Integer.toString(colorAssigned.getBlue()));
			} else {
				colorXml.addAttribute("name", exactMatchColor);
			}
		}
	}

	/** method to snap object to bottom and x-y center of a particular shape.  currently used
	 * for snapping to container shape, but could be used for general alignment */
	public void snapToCenter(SimShape ofShape) {
		Point2D shapeCenter = ofShape.getCenter();
		Point2D currentCenter = this.getShape().getCenter();

		ObjectMover.translate(this, shapeCenter.getX() - currentCenter.getX(),
				shapeCenter.getY() - currentCenter.getY(),
				ofShape.getZ() - this.getShape().getZ());
	}
}

