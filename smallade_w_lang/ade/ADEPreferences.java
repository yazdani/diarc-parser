/**
 * Agent Development Environment (ADE)
 *
 * @version 1.0
 * @author Matthias Scheutz
 *
 * Copyright 1997-2013 Matthias Scheutz and the HRILab Development Team
 * All rights reserved.  For information or questions, please contact
 * the director of the HRILab, Matthias Scheutz, at mscheutz@gmail.com
 * 
 * Redistribution and use of all files of the ADE package, in source and
 * binary forms with or without modification, are permitted provided that
 * (1) they retain the above copyright notice, this list of conditions
 * and the following disclaimer, and (2) redistributions in binary form
 * reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR ANY
 * OF THE CONTRIBUTORS TO THE ADE PROJECT BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.

 * Note: This license is equivalent to the FreeBSD license.
 */
package ade;

import java.awt.Color;
import java.io.*;
import java.util.*;

/**
 * Basic settings for the ADE system.
 */
public class ADEPreferences implements Serializable, Cloneable {

    private static final long serialVersionUID = 7526472295622776147L;
    // TODO: Ugh; inherited code that is evidently unfinished. I separated out
    // the GUI components so this can be used non-graphically, but the actual
    // preferences need help (as does the gui, but that's documented in that
    // class).
    // the default preferences
    /**
     * The timeout (in ms) allowed before timing out on a remote call.
     */
    static public int RC_TIMEOUT = ADEGlobals.DEF_HBPULSE;
    // the host settings
    /**
     * Default IP address (127.0.0.1).
     */
    static public String HOSTIP = "127.0.0.1";
    /**
     * Default hostname (localhost).
     */
    static public String HOSTNAME = "localhost";
    /**
     * Default operating system (Linux).
     */
    static public ADEGlobals.HostOS HOSTOS = ADEGlobals.HostOS.LINUX;
    /**
     * Default number of processing units (1).
     */
    static public int CPUS = 1;
    /**
     * Default processing speed.
     */
    static public int CPUMHZ = 2000;
    /**
     * Default total system memory.
     */
    static public int MEMMB = 1024000;
    /**
     * The default home directory of the ADE system. Note that relative paths
     * are acceptable for startup, so long as the path prefix is the user's home
     * directory.
     */
    static public String ADEHOME = "/home/airolab/ade-svn/ade/";
    /**
     * The default directory that contains config/hosts files for the ADE
     * system. Note that if the path is relative, it will be appended to the
     * {@link #ADEHOME} path.
     */
    static public String ADECONF = "config" + System.getProperty("file.separator");
    /**
     * The default directory in which to store log files generated by the ADE
     * system. Note that if the path is relative, it will be appended to the {@link
     * #ADEHOME} path.
     */
    static public String ADELOGS = "logs" + System.getProperty("file.separator");
    static public String SCRATCH = "/tmp/";
    static public String JAVABIN = "/usr/bin/java";
    static public String JAVAHOME = "/usr/java/jdk1.5.0_03/";
    static public String COMPILER = "/usr/bin/javac";
    // the GUI settings
    static public String FONT = "SansSerif";
    static public int FONTSIZE = 12;
    static public int[] CCOLOR = {0x9900, 0x9900, 0xff, 0xff9900, 0xff0000, 0x9999ff, 0x650099, 0xcc00cc, 0xffc800, 0xff9900};
    static public int[] JCOLOR = {0x9900, 0x9900, 0xff, 0xff9900, 0xff0000, 0x9999ff, 0x650099, 0xcc00cc, 0xffc800, 0xff9900};
    static public int[] JSCOLOR = {0x9900, 0x9900, 0xff, 0xff9900, 0xff0000, 0x9999ff, 0x650099, 0xcc00cc, 0xffc800, 0xff9900};
    static public int[] HCOLOR = {0x9900, 0x9900, 0xff, 0xff9900, 0xff0000, 0x9999ff, 0x650099, 0xcc00cc, 0xffc800, 0xff9900};
    static public int[] JSPCOLOR = {0x9900, 0x9900, 0xff, 0xff9900, 0xff0000, 0x9999ff, 0x650099, 0xcc00cc, 0xffc800, 0xff9900};
    private HashMap<String, Boolean> preferences;

    public ADEPreferences(String filepath) {
        //read in the preferences from a file
        initTable(filepath);
    }

    //default constructor
    //used for supervisor mode
    public ADEPreferences() {
        initTable();
    }

    public void SetDefaultPreferences() {
    }

    private void initTable() {
        preferences = new HashMap<String, Boolean>();
        SetDefaultPreferences();
    }

    private void initTable(String filename) {
        readPreferences(filename);
    }

    static private String arrToStr(String[] arr) {
        StringBuilder sb = new StringBuilder();
        for (String s : arr) {
            sb.append(s);
            sb.append(" ");
        }
        sb.setLength(sb.length() - 1);
        return sb.toString();
    }

    boolean readStream(ObjectInputStream p) {
        try {
            preferences = (HashMap<String, Boolean>) p.readObject();
            if (preferences == null) {
                System.out.println("Null table");
                System.exit(0);
            }
            return true;
        } catch (StreamCorruptedException e2) {
            System.out.println("Stream corrupted!");
            return false;
        } catch (IOException e1) {
            System.out.println("I/O Exception " + e1);
            return false;
        } catch (ClassNotFoundException e3) {
            System.out.println("Class not found!");
            return false;
        }
    }

    boolean writeStream(ObjectOutputStream p) {
        try {
            p.writeObject(preferences);
            return true;
        } catch (StreamCorruptedException e2) {
            System.out.println("Stream corrupted!");
            return false;
        } catch (IOException e1) {
            System.out.println("I/O Exception " + e1);
            return false;
        }
    }

    boolean readPreferences(String filepath) {
        try {
            FileInputStream istream = new FileInputStream(filepath);
            ObjectInputStream p = new ObjectInputStream(istream);
            preferences = (HashMap<String, Boolean>) p.readObject();
            if (preferences == null) {
                System.out.println("Null table");
                System.exit(0);
            }

            p.close();
            istream.close();
            return true;
        } catch (StreamCorruptedException e2) {
            System.out.println("Stream corrupted!");
            return false;
        } catch (IOException e1) {
            System.out.println("I/O Exception " + e1);
            return false;
        } catch (ClassNotFoundException e3) {
            System.out.println("Class not found!");
            return false;
        }
    }

    boolean writePreferences(String filepath) {

        try {
            FileOutputStream ostream = new FileOutputStream(filepath);
            ObjectOutputStream p = new ObjectOutputStream(ostream);

            p.writeObject(preferences);      // permisions hashtable
            p.flush();
            p.close();
            ostream.close();
            return true;
        } catch (StreamCorruptedException e2) {
            System.out.println("Stream corrupted!");
            return false;
        } catch (IOException e1) {
            System.out.println("I/O Exception " + e1);
            return false;
        }
    }

    /**
     * Sets the state of a given boolean switch to true or false
     *
     * @param vers - The String value of boolean that need to be converted
     */
    boolean setState(String vers) {
        return Boolean.valueOf(vers).booleanValue();
    }

    public void setValue(String key, boolean val) {
        if (preferences.put(key, new Boolean(val)) == null) {
            System.out.println("Problem encountered with preferences hashtable: An expected value is null, " + key);
        }
    }

    /**
     * Converts a color object to its hex value. The hex value prefixed is with
     * #, for example #ff0088.
     *
     * @param c The color object
     */
    public static String getColorHexString(Color c) {
        String colString = Integer.toHexString(c.getRGB() & 0xffffff);
        return "#000000".substring(0, 7 - colString.length()).concat(colString);
    }

    /**
     * Converts a hex color value prefixed with #, for example #ff0088.
     *
     * @param name The color value
     */
    public static Color parseColor(String name) {
        if (name == null) {
            return Color.black;
        } else if (name.startsWith("#")) {
            try {
                return Color.decode(name);
            } catch (NumberFormatException nfe) {
                return Color.black;
            }
        }
        return Color.black;
    }
    // for generating unique symbols (like "gensym")
    private static HashMap<String, Integer> h = new HashMap<String, Integer>();

    public synchronized static String gensym(String sym) {
        Integer I = h.get(sym);
        if (I == null) {
            // add new gensym entry
            h.put(sym, new Integer(1));
            return sym + 1;
        } else {
            // retrieve entry and increment counter
            int i = I.intValue();
            h.put(sym, new Integer(++i));
            return sym + i;
        }
    }

    // for external maps
    public synchronized static String gensym(String sym, HashMap<String, Integer> h) {
        Integer I = h.get(sym);
        if (I == null) {
            // add new gensym entry
            h.put(sym, new Integer(1));
            return sym + 1;
        } else {
            // retrieve entry and increment counter
            int i = I.intValue();
            h.put(sym, new Integer(++i));
            return sym + i;
        }
    }
}
